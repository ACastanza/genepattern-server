# begin all SSOAP in one.R

SOAP.logical <-
function(x)
{
  val <- as.logical(x)

  if(is.na(val)) {
   val <- as.logical(as.integer(x))
  }

  val
}  

SOAPPrimitiveConverters <-
                list("xsd:timeInstant" = as.POSIXct,
                     "xsd:float" = as.numeric,
                     "xsd:int" = as.integer,
                     "xsd:float" = as.numeric,
                     "xsd:string" = as.character,
                     "xsd:boolean" = SOAP.logical,
# Extensions from Datatypes schema                     
                     "xsd:decimal" = as.numeric)


getNodeById <-
  #
  # Find the top-level node identified by id=value of id
  # Strip the `#' prefix off `id' first.
function(id, root)
{
  id <- gsub("^#", "", id)

  for(i in xmlChildren(root)) {
    k <- xmlAttrs(i)
    if(!is.null(k) && !is.na(match("id", names(k))))
      if(id == k[["id"]])
        return(i)
  }

  return(NULL)
}


# Also need general converters that work on nodes
fromSOAP <-
  #
  # Top-level entry point to convert a top-level SOAP XML node to 
  # 
function(node, root = NULL, converters = SOAPPrimitiveConverters, append = TRUE)
{
  if(!missing(converters) && append) {
    SOAPPrimitiveConverters[names(converters)] <- converters
    converters <- SOAPPrimitiveConverters
  }
  
  if(is.character(node)) {
    root <- parseSOAP(node)
    if(xmlName(root) == "Body")
      node <- root[[1]]
    else
      node <- root
  }
  
  type <- NULL
  a <- xmlAttrs(node)
  
  if(!is.null(a)) {
    if(!is.na(match("null", names(a))))
      return(NULL)

    if(!is.na(match("type", names(a))))
      type <- a[["type"]]

    if(!is.na(match("href", names(a)))) {
      n <- getNodeById(a[["href"]], root)
      if(is.null(n))
        stop("Can't find element ", a[["href"]])
      return(fromSOAP(n, root = root, converters = converters))
    }
  }

  if(xmlName(node) == "Array" || (!is.null(type) && type == "soapenc:Array")) {
    return(fromSOAPArray(node, root = root, converters = converters))
  } else if(xmlSize(node) > 1) {
    return(fromSOAPStruct(node, root = root, converters = converters))
  } 

  if(is.null(type)) {
     # Want to check namespace is soapenc
     # and ideally don't want to prefix it with xsd:
     # but probably the most usual case is to get the typ
     # as xsd:type from the attribute and so that is the
     # default.
    type <- paste("xsd", xmlName(node), sep=":")
  }
  
  which <- match(type, names(converters))
  if(!is.na(which))
    val <- converters[[which]](xmlValue(node))
  else {
    val <- xmlValue(node)
    warning("Don't understand the SOAP type `", type, "' yet")
  }

  val
}


fromSOAPArray <-
  # Need to handle the partial arrays
  # where individual elements are  specified.
  #
function(node, type = NULL, root = NULL, converters = SOAPPrimitiveConverters)
{
  len <- xmlSize(node)
  a <- xmlAttrs(node)  

  if(missing(type)) {
    type <- a[["arrayType"]]
    if(!is.null(type)) {
      els <- strsplit(type, ":")[[1]]
      type <- gsub("\(.*\)\\\[.*", "\\1", els[2])
      len <- as.integer(gsub(".*\\\[\([0-9,]+\)\\\]", "\\1", els[2]))
      cat("Type:", type, " & length = ", len, "\n")
    }
  }


   # This is the general mechanism for dealing with offsets.
   # It doesn't work in S-Plus since it uses lexical scoping.
   # Need an OOP object for that.
  offset <- 1 
  if(!is.na(match("offset", names(a)))) {
    tmp <- gsub("\\\[\([0-9]+\)\\\]", "\\1", a[["offset"]])
    offset <- as.integer(tmp)
  }

  ans <- vector("list", len)
  val <- xmlApply(node, function(x, type = NULL, root = NULL, converters = SOAPPrimitiveConverters) {
                           z <- fromSOAP(x, root = root, converters = converters)

                           a <- xmlAttrs(x)
                           if(!is.null(a) && !is.na(match("position", names(a)))) {
                             offset <- as.integer(a[["position"]]) + 1
                           }                           

                           ans[[offset]] <<- z
                            # Do we need to differentiate between this coming from
                            # the position or the global offset.
                            # In the case of position, each item will provide 
                            # its own position value.
                           offset <<- offset + 1
                           z
                        }, type=type, converters = converters, root = root)

  return(ans)
}

fromSOAPStruct <-
function(node, root = root, converters = SOAPPrimitiveConverters)
{

   # See if there is a type="value" attribute which we will use
   # for the class.
  a <- xmlAttrs(node)  
  if(!is.null(a) && !is.na(match("type", names(a)))) {
    typeName <- a[["type"]]
  } else
    typeName <- xmlName(node)

  # Now lookup the converters to see if there is an appropriate
  # handler for this type.

  # Otherwise, just use the default mechanism.
  val <- xmlApply(node, fromSOAP, root = root, converters = converters)

  class(val) <- gsub("^[a-zA-Z]+:", "", typeName)
  
  val
}  


# XXX: JL: added missing [["Body"]][["Fault"]] dereferences to fault trace
SOAPFault <-
function(node)
{
 faultClassNames <- c("Client"="SOAPClientFault",
                      "Server"="SOAPServerFault",
                      "MustUnderstand" = "SOAPMustUnderstandFault",
                      "VersionMismatch" = "SOAPVersionMismatchFault")        
  
 if(is.character(node)) {
   node <- parseSOAP(node)
 }
  
 code <- xmlValue(node[["Body"]][["Fault"]][["faultcode"]])
 els <- strsplit(code, ":")[[1]]
   # Check that the namespace of the fault is appropriate for us to look
   # for a built-in fault.
  els[1] <- toupper(els[1])

  if(els[1] != "SOAP" && els[1] != "soapenv")
    code <- NULL
  else
    code <- els[2]

 if(!is.null(code) && !is.na(match(code, names(faultClassNames)))) {
  className <- faultClassNames[[code]]
 } else
  className <- "SOAPGeneralFault"
 
 f <- new(className)

 f@message <- xmlValue(node[["Body"]][["Fault"]][["faultstring"]])

 if(!is.null(node[["Body"]][["Fault"]][["actor"]]))
   f@actor <- xmlValue(node[["Body"]][["Fault"]][["actor"]]) 

 f@detail <- node[["Body"]][["Fault"]][["detail"]]

 f
}  

gpGetHttpContent <-
  #
  # Reads the lines from the HTTP response 
  # header and converts them into a
  # name=value  collection as a character vector.
  #
function(lines)
{
 if(length(lines) < 1)
   return(NULL)

  # Not able to use read.dcf() here since we would have to write
  # these lines to a file. Use a textConnection?
  # header <- paste(lines[1:(b[1]-1)], collapse="\n")
  # header <- read.dcf(header) 
 b <- (1:length(lines))[lines  == ""]

 els <- sapply(lines[2:(b[1]-1)], function(x) strsplit(x, ":"))
 header <- sapply(els, function(x) x[2])
 names(header) <- sapply(els, function(x) x[1]) 

 els <- strsplit(lines[1], " ")[[1]] 
 header[["status"]] <- as.integer(els[2])
 header[["statusMessage"]] <- els[3]
 
  # Now paste the content or payload of the HTTP communication
 content <- paste(lines[(b[1]+1):length(lines)], collapse="\n")
 # strip off a possible MIME header preceding the XML
 content <- substr(content, as.integer(regexpr("<?xml ", content, extended=FALSE)), nchar(content))
 return(list(header = header, content = content))
}

isHTTPError <-
  #
  # Looks at the elements of the HTTP response
  # header, assumed to be pre-processed into name-value pairs,
  # and figures out whether the response indicates an error
  # or success.
  # It does this by looking for the non name-value pair
  # corresponding to the `HTTP/1.1 status message' string.
  # It then gets the status and compares it to the value 200.
function(response)
{
  response[["status"]] != 200
}  

parseSOAP <-
function(xmlSource, header = FALSE, reduce = FALSE, ...)
{
#JL: added ", replaceEntities = TRUE"
   node <- xmlRoot(xmlTreeParse(xmlSource, ..., replaceEntities = TRUE))
   if(reduce) {
     if(xmlName(node) == "Envelope")
       node <- node[[1]]

     if(xmlName(node) == "Body")
       node <- node[[1]]
   }

   node
}

# Create XML to invoke a SOAP method

toSOAP <-
function(obj, con = xmlOutputBuffer(header=""))
{

 writeTypes <- function(x) {
      types <- getSOAPType(x)
      if(!is.null(types)) {
       for(a in names(types)) {
         cat(a,"=\"", types[[a]],"\" ", sep="", file=con)
       }
      }   
 }
  
 # con$add("value")
 if(length(obj) > 1) {
  if(!is.null(names(obj))) {
    for(i in names(obj)) {
      cat("<", i, file = con, sep="")
      writeTypes(obj[[i]])
      cat(obj[[i]])
    }
  } else {
    for(i in obj) {
      cat("<item", file=con)
      writeTypes(i)
      cat(">\r\n", file=con)
      cat(obj, file=con)
      cat("\r\n</item>", file=con)      
    }
  }
 } else {
    cat(obj, file=con)
 }

 invisible(TRUE)
}  

SOAPTypes <-
  list("character" = c("xsi:type" = "xsd:string"),
       "numeric" = c("xsi:type" = "xsd:float"),
       "double" = c("xsi:type" = "xsd:float"),       
       "integer" = c("xsi:type" = "xsd:int"),
       "logical" = c("xsi:type" = "xsd:boolean"),
       "NULL" = c("xsi:null" = 1)
    )

getSOAPType <-
function(obj)
{
  if(is.null(obj) || length(obj) == 0)
    return(SOAPTypes[["NULL"]])

  if(length(obj) > 1) {
    # Array
    n <- length(obj)
    same <- sapply(obj, function(x, target) typeof(x) == target, target = typeof(obj[[1]]))

    ans <- c("soapenc:Array")
    if(all(same)) {
      type <- getSOAPType(obj[[1]])
      ans[["soapenc:arrayType"]]  = paste(type[1], "[", n, "]", sep="")
    }
    
  } else {
     m <- typeof(obj)
     ans <- SOAPTypes[[m]]
  }
  
  return(ans)  
}  

.SOAPAction <-
function(action, method, server, xmlns)
{
  paste(action, "#", method, sep="")
}

.SOAPDefaultHandlers <-
  list(action = .SOAPAction,
       result = function(xmlSource, header, method, server) {
 # JL: reduce = FALSE
         response <- parseSOAP(xmlSource, asText = TRUE, reduce = FALSE)
 # JL: ???
         fromSOAP(response[[1]])
       })

SOAPHandlers <-
function(..., include = character(0), exclude = character(0))
{  
 defaults <- .SOAPDefaultHandlers
 els <- list(...)

 .merge(els, defaults, include, exclude)
}

.SOAP <-
function(server, method, ..., action, nameSpaces = SOAPNameSpaces(), xmlns = NULL,
          handlers = SOAPHandlers(), debug = FALSE)  
{
  # Get the connection.
 if(debug) {
   con <- textConnection(".SOAPTest", "w")
 } else {
   con <- socketConnection(server@host, port = server@port, open = "w+", blocking = TRUE)
 }
 on.exit(close(con))

 if(is.null(xmlns))
   xmlns <- c(namesp1 = action)

 if(!is.null(handlers) && !is.na(match("action", names(handlers)))) 
   action <- handlers[["action"]](action, method, server, xmlns)
 
 writeSOAPHeader(server@url, server@host, action, con)

 txt <- writeSOAPMessage(con, nameSpaces, method, ..., xmlns = xmlns)

 cat("User-agent: ", R.version[["major"]], ".", R.version[["minor"]], "\r\n", sep="", file=con)
 cat("Content-Length: ", nchar(txt),"\r\n", sep="", file=con)
 cat("\r\n", file=con)
 cat(txt, sep="\n", file=con)

 cat("\n", file=con)
 
 if(debug) {
   return(.SOAPTest)
 }


  # Now read the response from the server.
 txt <- readLines(con) 

  # Parse this into the HTTP header and the payload. 
 content <- gpGetHttpContent(txt)

  # Check things were ok with the HTTP.
 if(isHTTPError(content[["header"]])) {
     # This would be the exception that we throw if we had an exception system.
   fault <- SOAPFault(parseSOAP(content[["content"]], asText = TRUE))
    # 
   stop("Error occurred in the HTTP request: ", fault@message, fault@detail)
   return(fault)
 }

 if(!is.null(handlers) && !is.na(match("result", names(handlers))))
   return(handlers[["result"]](content[["content"]],  content[["header"]], method))

 return(content)
}


writeSOAPHeader <-
function(url, host, action, con, ...)
{
 # JL: HTTP 1.0, not 1.1, to avoid extra status codes in returned result from Axis/Apache
 cat("POST /", gsub("^/", "", url), " HTTP/1.0\r\n", sep="", file=con)
 cat("Host: ", host, "\r\n", sep="", file=con)
 cat("Content-Type: text/xml; charset=utf-8\r\n", file=con)
 if(!is.null(action))
   cat("SOAPAction: \"", action, "\"\r\n", sep="", file=con)

 args <- list(...)
 for(i in names(args)) {
    cat(i, ": ", args[[i]], sep="", file=con)
 }

}  


writeSOAPMessage <-
function(con, nameSpaces, method, ..., xmlns = NULL)
{
 con <- textConnection(".foo", open="w")
 writeSOAPEnvelope(con, nameSpaces = nameSpaces)

 writeSOAPBody(method, ..., xmlns = xmlns, con = con)

 cat("</soapenv:Envelope>\r\n", file=con)

  # Flushing to make certain the commands go to the server.
 cat("\r\n", file=con)
 close(con)
 paste(get(".foo"), collapse="\n")
}  


#SOAP 1.1
#      "soapenc" = 'http://schemas.xmlsoap.org/soap/encoding/',
#      "xsd" = 'http://www.w3.org/1999/XMLSchema',
# SOAP  1.2 
#      "soapenv" = 'http://www.w3.org/2002/06/soapenvelope',
#      "soapenc" = 'http://www.w3.org/2002/06/soapencoding',
#      "xsd" = 'http://www.w3.org/2001/XMLSchema',

.SOAPDefaultNameSpaces <-
  list("1.1" = 
         c(
           'soapenc'="http://schemas.xmlsoap.org/soap/encoding/",
           'soapenv'="http://schemas.xmlsoap.org/soap/envelope/",           
           'xsi'="http://www.w3.org/1999/XMLSchema-instance",
           'xsd'="http://www.w3.org/1999/XMLSchema"
           )  ,
       "1.2" = 
         c(
           'soapenc'="http://schemas.xmlsoap.org/soap/encoding/",
           'soapenv'="http://schemas.xmlsoap.org/soap/envelope/",
           'xsi'="http://www.w3.org/2001/XMLSchema-instance",
           'xsd'="http://www.w3.org/2001/XMLSchema"
           )  )       
       

.merge <-
function(els, defaults, include = NULL, exclude = NULL)
{
 if(length(els) > 0) {
   which <- match(names(defaults), names(els))
   if(any(!is.na(which)))
     els[names(defaults)[!is.na(which)]] <- defaults[!is.na(which)]
 } else
   els <- defaults

 if(length(include)) {
   els <- els[include]
 } else if(length(exclude)) {
   which <- match(exclude, names(els))
   if(any(!is.na(which)))
     els <- els[- (which[!is.na(which)])]
 }

 els   
}  

SOAPNameSpaces <-
function(..., include = character(0), exclude = character(0), version = "1.1")
{
  defaults <- .SOAPDefaultNameSpaces[[version]]
  els <- sapply(list(...), as.character)
  .merge(els, defaults, include, exclude)
}

  # This and writeSOAPBody should use the XMLOutput.. classes in the XML package.
writeSOAPEnvelope <-
function(con, nameSpaces = .SOAPNameSpaces())
{
  # JL: change apostrophes to quotes in the line below
  cat("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n", file = con)
  cat("<soapenv:Envelope\r\n", file=con)
  for(i in names(nameSpaces)) {
     cat(" xmlns:", i, "=\"", nameSpaces[i],"\"\r\n", sep="", file=con)
  }
  cat(' soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"', file=con)
  cat(">\r\n", file=con)
}


writeSOAPBody <-

function(method, ..., xmlns= NULL, con)
{
 cat('<soapenv:Body>\r\n', file=con)

 nsName <- ""
 if(!is.null(xmlns) && !is.null(names(xmlns))) {
   nsName <- paste(names(xmlns)[1], ":", sep="")
 }
 
 cat("<", nsName, method, sep="", file=con)  

 if(!is.null(xmlns) && xmlns != "") {
   ns <- ""
   if(!is.null(names(xmlns)))
     ns <-  paste(":", names(xmlns)[1], sep="")
   cat(" xmlns", ns,"=\"", xmlns,"\"", file=con, sep="")
 }
 cat(">", file=con)

 args <- list(...)
 argNames <- names(args)
 
# JL: allow no-argument method calls
 if (length(args) > 0)
 for(i in 1:length(args)) {
   
  type <- getSOAPType(args[[i]])
  if(!is.null(argNames))
    argName <- argNames[i]
  else
    argName <- letters[i]

  cat("<", argName, " ", sep="", file=con)
  if(type != "") 
    cat("xsi:type=\"", type, "\" ", file=con, sep="")
  cat(">", file=con)
  toSOAP(args[[i]], con)
  cat("</", argName, ">\r\n", sep="", file=con)  
 }

 cat("</", nsName, method, ">\r\n", sep="", file=con) 

 cat("</soapenv:Body>\r\n", file=con) 
}  

#
# x <- SOAPServer(url = "TimeService/TimeService.asmx", host = "www.nanonull.com")
# SOAPServer("www.omegahat.org", "/foo")
#
SOAPServer <-
function(host, url="/gp/servlet/AxisServlet", port = props[["serverPort"]],  s = new(className))
{

 if(missing(url)) {
   url <- gsub("^[fth]+tp:[/]*.[a-zA-Z.0-9]+\(/.*\)", "\\1", host)
   host <- gsub("\(^[fth]+tp:[/]*.[a-zA-Z.0-9]+\)/.*", "\\1", host)   
   if(url == host)
     url <- ""
 }
  
 if(length(grep("^http", host))) {
    className <- "HTTPSOAPServer"
 } else  if(length(grep("^ftp", host))) {
    className <- "FTPSOAPServer"
 } else
    className <- "SOAPServer"
         
 host <- gsub("^http://", "", host)
 host <- gsub("^ftp://", "", host) 
 
 s@host <- host

 s@url <- url

 if(!missing(port))            
   s@port <- as.integer(port)
 
 s
}  

gpNormalizeServer <-
# if the server specification is a URL, convert it to a SOAPServer object and return it
function(server) {
    if (class(server) == "character") {
	split <- unlist(strsplit(server, "/"))
	host <- split[length(split)]
	portNum <- unlist(strsplit(host, ":"))
	if (length(portNum) == 2) {
		 port <- as.integer(portNum[[2]])
		 host <- portNum[[1]]
	} else {
		port <- ifelse(split[[1]] == "https", 443, props[["serverPort"]])
	}
#	if (length(split) > 3) {
#		uri <- paste("/", split[4:length(split)], sep="", collapse="/")
#	} else {
		uri = "/gp/servlet/AxisServlet";
#	}

	server <- SOAPServer(paste("http://", host, sep="", collapse=""), uri, as.integer(port))
    }
    return(server)
}

# begin gpSOAP.R

gpGetTasks <-
#
# retrieves task list from Analysis server
# return array(3, n) of (ID, name, description) tuples
#
function(server=defaultServer, userID=get("userID", envir=globalenv()))
{
USE.SOAP <- FALSE
taskList <- list()
itemsPerTask <- 3
server <- gpNormalizeServer(server)

if (USE.SOAP) {
	content <- SOAPSendReceive(server, "getTasks", action = "getTasks", xmlns = c(ns1="Admin"), nameSpaces = SOAPNameSpaces(version = "1.2"))
#	if (!class(content) == "list") return (NULL)
	if (is.null(content)) return (NULL)
	if (is(content, "SOAPFault")) return(content)
	response <- parseSOAP(content[["content"]], asText = TRUE, reduce = FALSE)

	for (item in 2:xmlSize(response[["Body"]])) {
		i <- response[["Body"]][item][["multiRef"]]
		type <- xmlAttrs(i)[["type"]]
		if (length(grep(":TaskInfo$", type)) == 0) next # only process this if it ends with TaskInfo
		taskList <- c(taskList, c(name = xmlValue(i[["name"]]), 
					  ID = xmlValue(i[["ID"]]), 
					  description = paste("", xmlValue(i[["description"]]), sep="", collapse="")
					  ))
		taskList <- c(taskList, c(name = xmlValue(i[["LSID"]]), 
					  ID = xmlValue(i[["ID"]]), 
					  description = paste("", xmlValue(i[["description"]]), sep="", collapse="")
					  ))
	}
} else {
	# get the task list the quick way (no parameterInfo data, just id and name
	err <- try (content <- gpReadFile(paste("http://", server@host, ":", server@port, "/gp/getTasks.jsp?userid=", userID, sep="", collapse=""), timeout=3))
	if (is.null(content)) {
#		cat("no response from server, attempting to start it...", file=stderr())
#		system(props[["startServerCmd"]], invisible=FALSE, wait=FALSE)
#		Sys.sleep(5)
#		err <- try (content <- gpReadFile(paste("http://", server@host, ":", server@port, "/gp/getTasks.jsp?userid=", userID, sep="", collapse=""), timeout=5))
#		if (is.null(content)) {
			stop("unable to retrieve task list from ", "http://", server@host, ":", server@port, "/gp/getTasks.jsp?userid=", userID)
#		}
	}

	# make a list of ID=name entries
	content <- strsplit(content, "\r\n")[[1]]
	for (item in content) {
		splitItem <- unlist(strsplit(item, "="))
		taskList <- c(taskList, c(name = splitItem[[2]], ID = splitItem[[1]], description = ""))
	}
}

	dim(taskList) <- c(length(taskList)/itemsPerTask, itemsPerTask)
	response <- array(taskList, dim=c(itemsPerTask,length(taskList)/itemsPerTask), 
	       dimnames=list(c("name", "ID", "description"),taskList[seq(1, length(taskList), by=itemsPerTask)]))
	return (response)
}

gpGetIDofTask <-
#
# returns the ID number of a task of a given name
#
function(name, server=defaultServer)
{
	server <- gpNormalizeServer(server)
	tasks <- gpGetTasks(server)
	if (is.null(tasks)) stop("unable to retrieve list of available tasks from ", server@host, ":", server@port);
	if (is(tasks, "SOAPFault")) stop("error retrieving list of available tasks from ", server@host, ":", server@port, " because ", tasks@message, "\n", tasks@detail)
	return (gpGetTaskID(tasks, name, server))
}

gpGetTaskID <-
#
# takes an LSID or task name and returns a taskID (server-side database primary key)
#
function(taskArray, name, server=defaultServer)
{
	if (missing(name)) {
		stop("gpGetTaskID: missing task name")
	}
	if (missing(taskArray)) {
		if (exists("gpCachedTaskArray", envir=globalenv())) {
			taskArray <- gpCachedTaskArray;
		} else {
			taskArray <- gpGetTasks(server)
		}
	}
	taskID <- taskArray[match("ID", rownames(taskArray)), match(name, colnames(taskArray))]
	if (is.null(taskID[[1]])) {
		server <- gpNormalizeServer(server)
		stop("no task with name or LSID ", name, " on ", server@host, ":", server@port)
	}
	return(as.character(taskID))
}

gpGetTaskName <-
#
# takes an LSID or a task name and returns a task name
#
function(name, taskArray, server=defaultServer)
{
	if (missing(name)) {
		stop("gpGetTaskName: missing task name")
	}
	if (missing(taskArray)) {
		if (exists("gpCachedTaskArray", envir=globalenv())) {
			taskArray <- gpCachedTaskArray;
		} else {
			taskArray <- gpGetTasks(server)
		}
	}
	taskName <- taskArray[match("name", rownames(taskArray)), match(name, colnames(taskArray))]
	if (is.null(taskName[[1]])) {
		server <- gpNormalizeServer(server)
		stop("no task named ", name, " on ", server@host, ":", server@port)
	}
	return(as.character(taskName))
}

gpGetTaskLSID <-
#
# takes an LSID or a task name and returns a task name
#
function(name, taskArray, server=defaultServer)
{
	if (missing(name)) {
		stop("gpGetTaskLSID: missing task name")
	}
	if (missing(taskArray)) {
		if (exists("gpCachedTaskArray", envir=globalenv())) {
			taskArray <- gpCachedTaskArray;
		} else {
			taskArray <- gpGetTasks(server)
		}
	}
	taskID <- taskArray[match("ID", rownames(taskArray)), match(name, colnames(taskArray))]
	if (is.null(taskID[[1]])) {
		server <- gpNormalizeServer(server)
		stop("no task named ", name, " on ", server@host, ":", server@port)
	}
	# lookup the LSID, given the taskID, and look at the next row to get the LSID version rather than the named version
	taskLSID <- taskArray[match("name", rownames(taskArray)), match(taskID, taskArray[match("ID", rownames(taskArray)),])+1]
	return(as.character(taskLSID))
}

gpCheckStatus <-
#
# request status on a submitted job.  Returns text status (Not Started, Finished, Processing, Error, Timed Out)
# assumes that the Axis server is returning reference-structured responses.  For any of the completed statuses, 
# the status text is followed by a comma and either TRUE or FALSE, denoting whether there is a result file to 
# retrieve.
#
function(jobID, server=defaultServer)
{
	if (missing(jobID)) stop("gpCheckStatus: missing jobID")
	server <- gpNormalizeServer(server)
	content <- SOAPSendReceive(server, "checkStatus", as.integer(jobID), action = "checkStatus", xmlns = c(ns1="Analysis"), nameSpaces = SOAPNameSpaces(version = "1.2"))
	if (is.null(content)) {
		status <- new("status", busy=TRUE, jobID=as.integer(jobID), server=server)
		return (status)
	}
	if (class(content) != "list") {
		status <- new("status", busy=FALSE, success=FALSE, error=content@message, jobID=as.integer(jobID), server=server)
		return (status)
	}
	response <- parseSOAP(content[["content"]], asText = TRUE, reduce = FALSE)

	resultStatus <- xmlValue(response[["Body"]][["multiRef"]][["status"]])
	filenames <- NULL
	if (resultStatus %in% list("Finished", "Error", "Timed Out", "Processing")) {
		filenames <- NULL
		serverFilenames <- NULL

		# move stdout and stderr to next-to-last and last respectively
		stderr <- NULL
		stdout <- NULL

		for (item in 1:xmlSize(response[["Body"]])) {
			if (xmlName(response[["Body"]][[item]]) != "multiRef") next
			i <- response[["Body"]][item][["multiRef"]]
			if (length(grep(":ParmInfo$", xmlAttrs(i)[["type"]])) == 0) next # only process this if it ends with TaskInfo
			hasOutputFile <- (xmlValue(i[["outputFile"]]) == "true")
			if (hasOutputFile) {
				filename <- xmlValue(i[["value"]])
				names(filename) <- paste(".server.", xmlValue(i[["name"]]), sep="", collapse="")
				bName <- basename(filename)
				if (bName == "stderr.txt") stderr = filename
				else if (bName == "stdout.txt") stdout = filename
				else {
					serverFilenames <- c(serverFilenames, filename)
					filename <- paste("http://", server@host, ":", server@port, "/gp/retrieveResults.jsp?dirName=", dirname(filename), "&filename=", basename(filename), "&abs=1", sep="", collapse="")
					names(filename) <- as.character(xmlValue(i[["name"]]))
					filenames <- c(filenames, filename)
				}
			}
		}
		if (!is.null(stdout)) {
					filename <- stdout
					serverFilenames <- c(serverFilenames, filename)
					filename <- paste("http://", server@host, ":", server@port, "/gp/retrieveResults.jsp?dirName=", dirname(filename), "&filename=", basename(filename), "&abs=1", sep="", collapse="")
					names(filename) <- "stdout"
					filenames <- c(filenames, filename)
		}
		if (!is.null(stderr)) {
					filename <- stderr
					serverFilenames <- c(serverFilenames, filename)
					filename <- paste("http://", server@host, ":", server@port, "/gp/retrieveResults.jsp?dirName=", dirname(filename), "&filename=", basename(filename), "&abs=1", sep="", collapse="")
					names(filename) <- "stderr"
					filenames <- c(filenames, filename)
		}
		status <- new("status", busy=!(resultStatus %in% list("Error", "Finished", "Timed Out")), success=(resultStatus == "Finished"), hasOutput=!is.null(filenames), filenames=as.list(filenames), serverFilenames=as.list(serverFilenames), jobID=as.integer(jobID), server=server)
	} else {
		status <- new("status", busy=TRUE, jobID=as.integer(jobID), server=server)
	}
	return(status)
}

gpWaitForResults <-
#
# Wait until a job either completes or times out, and then return the results filename or the timed-out error status
#
function(jobID, retrieve=TRUE, server=defaultServer)
{
	if (missing(jobID)) stop("gpWaitForResults: missing jobID")
	if (!exists("runningOnServer", envir=globalenv())) runningOnServer <- FALSE
	server <- gpNormalizeServer(server)
	status <- gpCheckStatus(jobID, server=server)
	iterations <- 0
	while (status@busy) {
		if (iterations < 10) {
			# sleep briefly at first, until it seems like this will take awhile
			Sys.sleep(1)
		} else {
			Sys.sleep(POLLING.INTERVAL)
		}
		iterations <- iterations + 1
		status <- gpCheckStatus(jobID, server=server)
	}
	if (status@success) {
		# it's done, is there a result file?
		if (status@hasOutput)
			if (retrieve) {
				return(gpGetResults(jobID, server=server))
			} else {
				result <- new("result", success=TRUE, filenames=status@serverFilenames, jobID=as.integer(jobID), server=server)
				return(result)
			}
		else
			return(status)
	} else {
		# JL: throw an exception
		if (status@hasOutput && (retrieve || !runningOnServer)) {
			results <- gpGetResults(jobID, server=server)
		}
		if (!runningOnServer) {
			cat(paste("Error response for task ", jobID, ": ", 
				status@error, "\n", 
				ifelse(status@hasOutput, 
					paste(gpReadFile(results@filenames[["stderr.txt"]]), 
					      gpReadFile(results@filenames[["stdout.txt"]]), 
					      sep="\n"),
					status@error),
				sep="", collapse=""), file=stderr())
		}
		if (status@hasOutput)
			if (retrieve) {
				return(results)
			} else {
				result <- new("result", success=TRUE, filenames=status@serverFilenames, jobID=as.integer(jobID), server=server)
				return(result)
			}
		else
			return(status)
	}
	return(NULL)
}

gpGetResults <-
#
# return task results structure
#
function(jobID, server=defaultServer)
{
	server <- gpNormalizeServer(server)
	status <- gpCheckStatus(jobID, server)
	if (!status@hasOutput) {
		result <- new("result", success=FALSE, error=status@error, filenames=list(NULL), jobID=as.integer(jobID), server=server)
	} else {
		for (i in 1:length(status@filenames)) { 
			filename <- names(status@filenames[i]);
			if (file.exists(filename)[1]) filename <- paste("job_", jobID, "_", filename, sep="", collapse="")
			download.file(url=status@filenames[[i]], filename, quiet=TRUE, mode="wb", cacheOK=FALSE)
		}
		result <- new("result", success=TRUE, filenames=status@filenames, jobID=as.integer(jobID), server=server)
	}
	return(result)
}

gpSubmitJob <- 
#
# submit a job to the OmniGene Analysis service and return the job ID number, which will be used to wait for results
# assumes Axis server is returning reference-based results
#
function(taskName, server=defaultServer, taskID, ...)
{

 server <- gpNormalizeServer(server)
 if (!exists("gpEncodedUserName", envir=globalenv()) || gpEncodedUserName == "") {
	gpEncodedUserName <<- gpLogin(userID, server)
 }
 # split input arguments into parameters and filenames.  Filenames have "filename" in the name of the parameter.
 args <- list(...)
 items <- list()
 files <- list()
 contentIDs <- list()
 fileSizes <- 0
 numServerFiles <- 0

 for (i in seq(along=args)) { 
 	if (is.null(args[[i]])) next # skip null values
	name <- names(args[[i]])
	name <- ifelse(is.null(name), "", name)
	if (class(args[[i]]) == "resultFilename") {
		args[[i]] <- args[[i]]@value
		name <- names(args[[i]])
		name <- ifelse(is.null(name), "", name)
	}
 	isServerFile <- (length(grep("^\.server\.", name)) != 0)
 	if (length(grep("filename", as.character(names(args[i])))) > 0 && 
	    length(grep("^http:", as.character(args[[i]]))) == 0 && 
	    length(grep("^https:", as.character(args[[i]]))) == 0 && 
	    length(grep("^ftp:", as.character(args[[i]]))) == 0 && 
	    length(grep("^<GenePatternURL>", as.character(args[[i]]))) == 0) { 
		if (!isServerFile) {
			if (is.null(args[[i]]) || nchar(args[[i]]) == 0) next
			if (file.access(args[[i]], 0) == -1) {
				stop("Input file ", args[[i]], " doesn't exist");
			}
			if (file.access(args[[i]], 4) == -1) {
				stop("No read permission for ", args[[i]])
			}
			f <- args[i]
			fSize <- file.info(args[[i]])[["size"]] #+2
			attachmentID <- as.character(runif(1))
			attachmentID <- substring(attachmentID, 3, nchar(attachmentID))
		} else {
			fSize = 0;
			numServerFiles <- numServerFiles + 1
			# mark server files in the list with empty attachmentIDs
			attachmentID <- ""
			f <- args[[i]]
			names(f) <- names(args[i])
		}
		files <- c(files, f)
		fileSizes <- fileSizes + fSize
		contentIDs <- c(contentIDs, attachmentID) # generate a "random" attachmentID
 	} else { 
		args[i] = gpHtmlEncode(as.character(args[i]))
		items <- c(items, args[i])
 	}
 }

  
 action = "submitJob"
 method <- action
 xmlns = c(ns1="Analysis")
 nameSpaces = SOAPNameSpaces(version = "1.2")
 handlers = SOAPHandlers()
 debug = FALSE
 boundary <- "----=_Part_0_602878.1038324861903"
 start <- "<4B95484DFBBD445E1E81CC0F08717937>"


 idOfTask <- ifelse(missing(taskID), gpGetIDofTask(taskName, server=server), as.character(taskID))

 if(!is.null(handlers) && !is.na(match("action", names(handlers)))) 
   action <- handlers[["action"]](action, method, server, xmlns)

measuredContent <- paste(
     '--', boundary, '\r\n',
     'Content-Type: text/xml; charset=UTF-8\r\n',
     'Content-Transfer-Encoding: binary\r\n',
     'Content-Id: ', start, '\r\n',
 
# writeSOAPEnvelope(con2, nameSpaces = nameSpaces)
     '\r\n',
     '<?xml version="1.0" encoding="UTF-8"?>\n',
     '<soapenv:Envelope\r\n xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"\r\n xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"\r\n xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r\n xmlns:xsd="http://www.w3.org/2001/XMLSchema"\r\n soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n',

     ' <soapenv:Body>\n',
     '  <ns1:submitJob soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns1="Analysis">\n',

     '   <arg0 xsi:type="xsd:int">', idOfTask, '</arg0>\n',

     '   <arg1 xsi:type="soapenc:Array" soapenc:arrayType="ns1:ParmInfo[', 
         length(items) + length(files),
     ']" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/">\n',

	paste(sapply(seq(along=args), function(i) { paste('    <item href="#id', names(args[i]), '"/>\n', sep="") }), sep="", collapse=""),

    '   </arg1>\n',
    '   <arg2 href="#filedescriptions"/>\n',
    '  </ns1:submitJob>\n',

# filename map
    '  <multiRef id="filedescriptions" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:Map" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="http://xml.apache.org/xml-soap">\n',
	paste(sapply(seq(along=files), function(i) { 
	    fname <- unlist(strsplit(basename(files[[i]]),"[?=&]"))
	    fname <- fname[[length(fname)]]

 	    isServerFile <- contentIDs[[i]] == ""
	    if (!isServerFile) {
		    paste(
		    '   <item>\n',
		    '   <key xsi:type="xsd:string">', fname, '</key>\n',
		    '   <value href="cid:', contentIDs[[i]], '" xmlns:ns3="Analysis"/>\n',
		    '   </item>\n',
		    sep="", collapse="")
	    }
	  }), sep="", collapse=""),
    '  </multiRef>\n',

# filenames and descriptors
	paste(sapply(seq(along=files), function(i) { 
	    fname <- unlist(strsplit(basename(files[[i]]),"[?=&]"))
	    fname <- fname[[length(fname)]]
 	    isServerFile <- contentIDs[[i]] == ""

	    paste(
	    '  <multiRef id="id', names(files[i]), '" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:ParmInfo" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="Analysis">\n',
	    '   <attributes href="#fd', names(files[i]), '"/>\n',
	    '   <name xsi:type="xsd:string">', names(files[i]), '</name>\n',
	    '   <value xsi:type="xsd:string">', ifelse(!isServerFile, fname, files[[i]]), '</value>\n',
	    '   <inputFile xsi:type="xsd:boolean">',ifelse(!isServerFile, 'true', 'false'),'</inputFile>\n',
	    '  </multiRef>\n',

	    '  <multiRef id="fd', names(files[i]), '" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:Map" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="http://xml.apache.org/xml-soap">\n',
	    '   <item>\n',
	    '   <key xsi:type="xsd:string">MODE</key>\n',
	    '   <value xsi:type="xsd:string">',ifelse(!isServerFile, 'IN', 'Cached'),'</value>\n',
	    '   </item>\n',
	    '   <item>\n',
	    '   <key xsi:type="xsd:string">TYPE</key>\n',
	    '   <value xsi:type="xsd:string">FILE</value>\n',
	    '   </item>\n',
	    '  </multiRef>\n',

	    sep="", collapse="") }), sep="", collapse=""),

# and do all of the normal parameters too
	paste(sapply(seq(along=items), function(i) { paste(
	    '  <multiRef id="id', names(items[i]), '" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:ParmInfo" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="Analysis">\n',
	    '   <description xsi:type="xsd:string"></description>\n',
	    '   <name xsi:type="xsd:string">', names(items[i]), '</name>\n',
	    '   <value xsi:type="xsd:string">', as.character(items[[i]]), '</value>\n',
	    '  </multiRef>\n',
	  sep="", collapse="") }), sep="", collapse=""),

	    
    ' </soapenv:Body>\n',
    '</soapenv:Envelope>\r\n',

    sep="", collapse="")

finale <- paste('--', boundary, '--', '\r\n', '\r\n', sep="")

attachmentOverhead <- nchar(paste(lapply(contentIDs, gpAttachmentHeader, boundary), sep="", collapse="")) + ((length(files)-numServerFiles) *2)
contentLength <- nchar(measuredContent) + fileSizes + attachmentOverhead + nchar(finale) 

# timeout duration is dependent on contentLength.  On pc11057, 18 MB requires just over 60 seconds
#oldTimeout <- options("timeout" = as.integer(contentLength/300000)+10)[[1]]
#cat("timeout=", options("timeout")[[1]], "seconds\n", file=stderr())

#cat("writing to socket at ", date(), "\n", file=stderr())
#flush.console()

con <- socketConnection(server@host, port = server@port, open = "w+", blocking = TRUE)
on.exit(close(con))

cat("POST /", gsub("^/", "", server@url), " HTTP/1.0\n",
     "Host: ", server@host, "\n",
     'Content-Type: multipart/related; type="text/xml"; start="', start, '"; boundary="', boundary, '"\n',
     'Accept: application/soap+xml, multipart/related, text/*\n',
     "User-agent: R ", R.version[["major"]], ".", R.version[["minor"]], "\n",
     "Content-Length: ", contentLength,"\n",
     'SOAPAction: ""\n',
     'Authorization: Basic ', gpEncodedUserName, '\n',
     "\r\n",
     "\r\n",
     measuredContent, 
     sep="", file=con)

# copy in the file without ingesting in one gulp into limited R memory    
 
 # iterate over files, copying them to the output socket
 for (i in seq(along=files)) { 
	isServerFile <- contentIDs[[i]] == ""
	if (isServerFile) next
	
  	filename <- files[[i]]
	cat(gpAttachmentHeader(contentIDs[[i]], boundary), sep="", file=con)
 	f <- file(filename, "rb", blocking=TRUE)
	txt <- readChar(f, BUFSIZE)
	while(nchar(txt) > 0) {
		lastChar <- substring(txt, nchar(txt), nchar(txt))
		cat(txt, sep="", file=con)
		txt <- readChar(f, BUFSIZE)
	}
	close(f)
#	if (lastChar != "\n" && lastChar != "\r") cat("\r\n", sep="", file=con)
	cat("\r\n", sep="", file=con)
  }
  cat(finale, "\r\n", sep="", file=con) # terminate boundary and add final LF

# Now read the response from the server.
oldWarn <- options(warn=-1)
#cat("waiting for response from server at", date(), "\n", file=stderr())
#flush.console()
#browser()
txt <- ""
err <- try (txt <- readLines(con))
#cat("back from socket read at", date(), "\n", file=stderr())
#browser()
if (class(err[[1]]) == "try-error") {
	cat("error from readLines\n", file=stderr())
	if (isWindows) flush.console()
#	browser()
}

options(warn=0)
#options("timeout"=oldTimeout)
if (nchar(txt[[1]]) == 0) stop("No response from server on submitJob ", taskName)
 
  # Parse this into the HTTP header and the payload. 
 content <- gpGetHttpContent(txt)

 # Check things were ok with the HTTP.
 if (is.null(content) || length(grep("text/xml", content[["header"]][["Content-Type"]])) == 0) {
   stop("Unexpected non-XML server response.  content=\n", content, "\ntxt=\n", txt)
   return(NULL)
 }

 if(isHTTPError(content[["header"]])) {
     # This would be the exception that we throw if we had an exception system.
   fault <- SOAPFault(parseSOAP(content[["content"]], asText = TRUE))
    # 
   stop("Error occurred in the HTTP request", fault@message, fault@detail)
   return(fault)
 }
response <- parseSOAP(content[["content"]], asText = TRUE, reduce = FALSE)
return(xmlValue(response[["Body"]][["multiRef"]][["jobNumber"]]))
#return(xmlValue(response[["Body"]][["submitJobResponse"]][["submitJobReturn"]][["jobNumber"]]))
}

gpAttachmentHeader <-
#
# create MIME attachment heading
#
function(attachmentID, boundary) { 
   if (attachmentID == "") return("");
   return(paste('--', boundary, '\r\n', 
    'Content-Type: application/octet-stream\r\n',
    'Content-Transfer-Encoding: binary\r\n',
    'Content-Id: <', attachmentID, '>\r\n',
    '\r\n', sep=""))
}

#
# read in the XML envelope, parse into HTTP header, and return it.  Leave the attachment payload for later
#
gpInhaleEnvelope <-
function (con) {
	 txt <- NULL
	 t <- readLines(con, n=1)
	 while (length(t) == 1) {
		txt <- c(txt, t[1])
		if (length(grep("</soapenv:Envelope>", t)) == 1) {
			break
		}
		t <- readLines(con, n=1)
	 }

	  # Parse this into the HTTP header and the payload. 
	 content <- gpGetHttpContent(txt)
	 return (content)
}

SOAPSendReceive <-
function(server, method, ..., action, nameSpaces = SOAPNameSpaces(), xmlns = NULL,
          handlers = SOAPHandlers(), debug = FALSE)  
{
	  # Get the connection.
	 if(debug) {
	   con <- textConnection(".SOAPTest", "w")
	 } else {
	   cerr <- try(con <- socketConnection(server@host, port = server@port, open = "w+", blocking = TRUE))
	   if(class(cerr[[1]]) == "try-error") {
	   	fault <- new("SOAPFault")
		fault@message <- paste("couldn't connect to GenePattern server ", server@host, ":", server@port, sep="", collapse="")
		fault@detail <- cerr
	   	return(fault)
	   }
	 }
	  # JL:
	 on.exit(close(con))

	 if(is.null(xmlns))
	   xmlns <- c(namesp1 = action)

	 if(!is.null(handlers) && !is.na(match("action", names(handlers)))) 
	   action <- handlers[["action"]](action, method, server, xmlns)
	 
	 if (method == "submitJob" || method == "getTasks") {
		 writeSOAPHeader(server@url, server@host, action, con, "Authorization"=paste("Basic", gpEncodedUserName))
	 } else {
		 writeSOAPHeader(server@url, server@host, action, con)
	 }

	 txt <- writeSOAPMessage(con, nameSpaces, method, ..., xmlns = xmlns)

	 cat("Content-Length: ", nchar(txt),"\r\n", sep="", file=con)
	 cat("\r\n", file=con)
	 cat(txt, sep="\n", file=con)
	 cat("\n", file=con)
	 
	 if(debug) {
	   return(.SOAPTest)
	 }

	  # Now read the response from the server.
	 oldWarn <- options("warn" = -1)[[1]] # avoid the readLines warning about an incomplete final line
#	 oldTimeout <- options("timeout" = 0)[[1]]

	 content <- gpInhaleEnvelope(con)

	 # Check things were ok with the HTTP.
	 if (is.null(content)) {
	   warning("No server response.  Is Axis server running at http://", server@host, ":", server@port, " ?")
	   return(NULL)
	 }
	 if (length(grep("text/xml", content[["header"]][["Content-Type"]])) == 0) {
	   stop("Unexpected non-XML server response", content)
	   return(NULL)
	 }

	 if(isHTTPError(content[["header"]])) {
	     # This would be the exception that we throw if we had an exception system.
	   fault <- SOAPFault(parseSOAP(content[["content"]], asText = TRUE))
	    # 
	   warning("Error occurred in the HTTP request\n", fault@message, "\n", fault@detail)
	   return(fault)
	 }

	# if(!is.null(handlers) && !is.na(match("result", names(handlers))))
	#   return(handlers[["result"]](content[["content"]],  content[["header"]], method))

	if (length(grep("multipart/related", content[["header"]][["Content-Type"]])) > 0) {
		# pull out filenames and contentIDs, so that when the attachments are extracted, the filenames can be used
		response <- parseSOAP(content[["content"]], asText = TRUE, reduce = FALSE)
		attachmentFilenames <- list()
		attachmentSizes <- list()
		originalNames <- list()
		for (i in 1:xmlSize(response[["Body"]])) {
			if (xmlName(response[["Body"]][[i]]) != "multiRef") next
			multiRef <- response[["Body"]][i][["multiRef"]]
			if (length(grep(":FileWrapper$", xmlAttrs(multiRef)[["type"]])) == 0) next # only process this if it's a FileWrapper
			contentID <- xmlAttrs(multiRef[["dataHandler"]])[["href"]]
			contentID <- substring(contentID, 5, nchar(contentID))
			filename <- xmlValue(multiRef[["filename"]])
			filename <- gsub("Axis[0-9]+axis_", "", filename) # strip off the AxisNNNNNaxis_ prefix to the filename
			names(filename) <- contentID
			originalNames <- c(originalNames, c(filename))

			# if file exists, prefix with the job number
			if (file.exists(filename)[1]) filename <- paste("job_", unlist(list(...)), "_", filename, sep="", collapse="")
			names(filename) <- contentID
			attachmentFilenames <- c(attachmentFilenames, c(filename))
			attachmentSize <- as.integer(xmlValue(multiRef[["length"]]))
			names(attachmentSize) <- contentID
			attachmentSizes <- c(attachmentSizes, attachmentSize)
		}
		CONTENTID.HEADING <- "Content-Id: "
		BOUNDARY.KEY <- "boundary=\""

		boundary <- paste("--", 
				  substr(content[["header"]][["Content-Type"]], 
				         (nchar(BOUNDARY.KEY)+regexpr(BOUNDARY.KEY, content[["header"]][["Content-Type"]])[1]), 
					 nchar(content[["header"]][["Content-Type"]])-1), 
				  sep="")
		finalBoundary <- paste(boundary, "--", sep="")

		stderr <- NULL
		stdout <- NULL
		repeat {
			isBinary <- FALSE
			# skip the header lines, but capture the Content-Id to match with the FileWrapper contentIDs
			txt <- readLines(con, 1)

			while (length(txt) > 0 && nchar(txt) != 0) {
				if (length(grep(CONTENTID.HEADING, txt)) == 1) {
					# strip MIME header name (past colon and space), and <brackets> around ID
					contentID <- substr(txt, nchar(CONTENTID.HEADING) + 2, nchar(txt)-1)
				}
				if (length(grep("^Content-Type: image/", txt))) isBinary <- T
				txt <- readLines(con, 1)
			}
			attachmentFilename <- file.path(getwd(), attachmentFilenames[[contentID]])
			# need to replace forward slashes with filesystem-appropriate ones.  file.path is broken!
			if (.Platform$file.sep == "\\") {
				attachmentFilename <- gsub("/", "\\\\", attachmentFilename, FALSE)
			}

			bName <- basename(originalNames[[contentID]])

			names(attachmentFilename) <- bName
			if (bName == "stdout.txt") stdout = attachmentFilename
			else if (bName == "stderr.txt") stderr = attachmentFilename
			else content[["attachmentFilenames"]] <- c(content[["attachmentFilenames"]], attachmentFilename)
			attachment <- file(attachmentFilename, ifelse(isBinary, "w+b", "w+b"), blocking=FALSE)

			if (isBinary) {
				# R's readChar handles null characters poorly, so we have to loop over input
				# by character to correctly output it to the attachment file
				for (i in 1:attachmentSizes[[contentID]]) {
					ch <- readChar(con, 1);
					if (length(ch) > 0 && nchar(ch) == 1) {
						# write a byte
						writeChar(ch, attachment, eos=NULL);
					} else {
						# write a NUL character
						writeChar("", attachment, eos="");
					}
				}
				# read blank line and boundary line
				txt <- readLines(con, n=1)
				txt <- readLines(con, n=1)
			} else {
				c <- readChar(con, attachmentSizes[[contentID]]);
				writeChar(object=c, con=attachment, nchars=attachmentSizes[[contentID]], eos=NULL);
				txt <- readLines(con, n=1)
				txt <- readLines(con, n=1)
			}

			close(attachment)
			if (length(txt) == 0 || txt == finalBoundary) break
		}
		if (!is.null(stdout)) content[["attachmentFilenames"]] <- c(content[["attachmentFilenames"]], stdout)
		if (!is.null(stderr)) content[["attachmentFilenames"]] <- c(content[["attachmentFilenames"]], stderr)
	} else {
		content[["attachmentFilenames"]] <- c()
	}
	
	content[["attachmentFilenames"]] <- as.list(content[["attachmentFilenames"]])
	options("warn"=oldWarn)
#	options("timeout"=oldTimeout)

	return(content)
}

r <- function(...) { 
 args <- list(...)
 for(i in names(args)) {
    cat(i, "=\"", args[[i]], "\"", sep="")
 }
}

runAnalysis <-
#
# run an analysis task remotely task, returning list of results filenames or status if error occurred
#
function(taskName, server=defaultServer, ...)
{
	server <- gpNormalizeServer(server)
	if (!exists("runningOnServer", envir=globalenv())) runningOnServer <- FALSE
	if (!exists("gpEncodedUserName", envir=globalenv())) gpEncodedUserName <<- gpLogin(userID, server)

	if (!exists("gpCachedTaskArray", envir=globalenv())) gpCachedTaskArray <<- gpGetTasks(server)

	if (runningOnServer) {
		args <- list(...)
		if (!exists("numTasksInPipeline", envir=globalenv()) || 
		    !exists("taskNum", envir=globalenv())) {
			numTasksInPipeline <<- 1
			taskNum <<- 1
		}
		cat("<tr><td valign=top rowspan=2 width=20><nobr>", taskNum, " of ", numTasksInPipeline, 
		    "</nobr></td><td valign=top>", taskName, "(", sep="")
		flush(stdout());
		first <- T
		for(i in names(args)) {
		    if (!first) cat(", ")
		    first <- F
		    cat(i, "=", sep="")
		    if (class(args[[i]]) == "character") {
			isURL <- (length(grep("^http", args[[i]])) != 0 || length(grep("^ftp", args[[i]])) != 0)
			cat("\"", ifelse(isURL, paste("<a href=\"", args[[i]], "\">", sep=""), ""), 
			    gpHtmlEncode(args[[i]]), 
			    ifelse(isURL, "</a>", ""), 
			    "\"", sep="")
		    } else {
			fn <- unlist(list(strsplit(as.character(args[[i]]@value), ifelse(isWindows, "\\\\", "/"))))
			cat("<a href=\"http://", server@host, ":", server@port, "/gp/retrieveResults.jsp?filename=", fn[[length(fn)]], "&dirName=", fn[[length(fn)-1]], "\">", args[[i]]@name, "</a>", sep="")
#			cat(args[[i]]@name)
		    }
		}
		cat(")</td></tr>\n")
		if (isWindows) flush.console()
	}

	if (exists("gpCachedTaskArray")) {
		taskID <- gpGetTaskID(gpCachedTaskArray, taskName, server)
		jobID <- gpSubmitJob(taskName=taskName, server=server, taskID=taskID, ...)
	} else {
		jobID <- gpSubmitJob(taskName=taskName, server=server, ...)
	}
	assign("lastJobID", jobID, env=parent.env(environment()))
	assign("lastTaskDir", getwd(), env=parent.env(environment()))
	result <- gpWaitForResults(jobID, retrieve=!runningOnServer, server=server)
	if (class(result) == "result") {
		result <- result@filenames
		if (runningOnServer) {
			numFiles <- length(result)
			cat("<tr><td valign=top>")
			if (numFiles == 0) {
				cat("No output from ", taskName, taskNum, "\n")
			} else {
				ignore <- lapply(result, function(f, numFiles, files) { 
						cat("\074input type=\"checkbox\" value=\"", taskName, taskNum, "/", basename(f), "=", f, "\" name=\"dl\" checked\076  \074a target=\"_blank\" href=\"http://", server@host, ":", server@port, "/gp/retrieveResults.jsp?filename=", basename(f), "&dirName=", basename(dirname(f)), "\"\076", basename(f), "\074/a\076", ifelse(numFiles == match(f, files), "\n", "  "), sep="")
						names(f) <- paste(taskName, taskNum, "_", basename(f), sep="", collapse="")
						close(url(paste("http://", server@host, ":", server@port, "/gp/updatePipelineStatus.jsp?jobID=", pipelineJobID, "&name=", taskName, taskNum, "&filename=", f, sep=""), open="r"))
						return(f)
					}, numFiles, result)
			}
			cat("</td></tr>\n")
			if (isWindows) flush.console()
			flush(stdout());
		}
	}

	if (runningOnServer) {
	    if (taskNum == numTasksInPipeline) {
		cat("</table>\n")
		cat("\074center\076\074input type=\"submit\" name=\"download\" value=\"download selected results\"\076")
		cat("&nbsp;&nbsp;\074a href=\"javascript:checkAll(this.form, true)\"\076check all\074/a\076 &nbsp;&nbsp; \074a href=\"javascript:checkAll(this.form, false)\"\076uncheck all\074/a\076\074/center\076")
		cat("\074br\076\074center\076\074input type=\"submit\" name=\"delete\" value=\"delete selected results\" onclick=\"return confirm('Really delete the selected files?')\"\076")
		cat("\074/form\076\n")
		if (exists("pipelineJobID")) {
			close(url(paste("http://", server@host, ":", server@port, "/gp/updatePipelineStatus.jsp?jobID=", pipelineJobID, sep=""), open="r"))
			rm(pipelineJobID, envir=parent.env(environment()))
		}
		rm(taskNum, numTasksInPipeline, envir=parent.env(environment()))
	    } else {
		    assign("taskNum", taskNum + 1, env=parent.env(environment()))
	    }
	    flush(stdout());
	}

	if (!runningOnServer) rm(gpCachedTaskArray, envir=globalenv())
	return (result)
}

gpHttpLength <- 
#
# return the length of a URL-based file without retrieving it
#
function(wwwAddress)
{
 split <- unlist(strsplit(wwwAddress, "/"))
 host <- split[3]
 portNum <- unlist(strsplit(host, ":"))
 if (length(portNum) == 2) {
	 port <- as.integer(portNum[[2]])
	 host <- portNum[[1]]
 } else {
	port <- ifelse(split[[1]] == "https", 443, 80)
 }
 uri <- paste(split[4:length(split)], sep="", collapse="/")
 con <- socketConnection(host, port, open = "w+", blocking = TRUE)
 on.exit(close(con))
 cat("HEAD /", uri, " HTTP/1.0\n\n", sep="", file=con)
 txt <- readLines(con) 
 content <- gpGetHttpContent(txt)

 if (isHTTPError(content[["header"]])) {
	fault <- new("SOAPFault")
	fault@message <- paste("Unable to get length of ", wwwAddress, sep="", collapse="")
	fault@detail <- txt[[1]]
	return(fault)
 }

 length <- as.integer(content[["header"]][["Content-Length"]])
 return(length) 
}

gpHtmlEncode <-
#
# encode protected characters (see htmlEncode in GenePatternAnalysisTask)
#
function(original)
{
  encoded <- gsub("&", "&amp;", original)
  encoded <- gsub("<", "&lt;", encoded)
  encoded <- gsub(">", "&gt;", encoded)
  return (encoded)
}

# begin gpio.R

gpAskUser <-
#
# prompt user interactively for a value
#
function(prompt, default="", stopIfBlank) {
	stopifnot(!missing(prompt))
	if (length(grep("filename", prompt)) > 0) return (gpAskUserFileChoice(prompt=prompt))
	if (!exists("runningOnServer", envir=globalenv())) runningOnServer <- FALSE
	if (missing(stopIfBlank)) stopIfBlank <- runningOnServer
	if (runningOnServer) {
		stop("Can't ask user questions from the server");
	}
	if (isWindows) {
		ret <- winDialogString(message=prompt, default=default)
		stopifnot(!(is.null(ret) && stopIfBlank))
	} else {
		cat(prompt, ifelse(nchar(default)> 0, paste(" (default is ", default, ")", sep=""), ": "), sep="");
		ret <- readLines(stdin(), n=1, ok=TRUE)[[1]];
		if (nchar(ret) == 0) ret <- default;
	}
	return(ret)
}

gpAskUserFileChoice <-
#
# prompt user interactively for a value
#
function(prompt) {
	stopifnot(!missing(prompt))
	if (!exists("runningOnServer", envir=globalenv())) runningOnServer <- FALSE
	if (runningOnServer) {
		stop("Can't ask user questions from the server");
	}
	if (isWindows) {
		stopifnot(winDialog(type="okcancel", message=prompt)=="OK")
		try (f <- file.choose())
		stopifnot(class(f) == "character")
		return(f)
	} else {
		return (gpAskUser(prompt))
	}
}

read.gct <- function(file) {
	if (is.character(file)) 
        if (file == "") 
            file <- stdin()
        else {
            file <- file(file, "r")
            on.exit(close(file))
        }
	if (!inherits(file, "connection")) 
        stop("argument `file' must be a character string or connection")
		  
   # line 1 version
	version <- readLines(file, n=1) 
	
	# line 2 dimensions
	dimensions <- scan(file, what=list("integer", "integer"), nmax=1, quiet=TRUE)   
	rows <- dimensions[[1]]
	columns <- dimensions[[2]]
	# line 3 Name\tDescription\tSample names...
	column.names <- read.table(file, header=FALSE, nrows=1, sep="\t", fill=FALSE) 
	column.names <-column.names[3:length(column.names)]

	
	if(length(column.names)!=columns) {
		stop("Number of sample names not equal to the number of columns.")	
	}
	
	colClasses <- c(rep(c("character"), 2), rep(c("double"), columns))
	
	x <- read.table(file, header=FALSE, quote="", row.names=NULL, comment.char="", sep="\t", colClasses=colClasses, fill=FALSE)
	row.descriptions <- as.character(x[,2]) 
	data <- x[seq(from=3, to=dim(x)[2], by=1)]
	
	column.names <- column.names[!is.na(column.names)]
	names(data) <- column.names
	
	row.names(data) <- x[,1]
	r <- new("gct", row.descriptions=row.descriptions, data=data)
}

read.res <- function(filename)
{
  # read line 1: sample names
  headings <- read.table( filename, header=FALSE, nrows=1, sep="\t", fill=FALSE)
  # delete the NA entries for the tab-tab columns
  headings <- headings[!is.na(headings)]
  names(headings) <- headings
  
  # read line 2: sample descriptions
  descriptions <- read.table( filename, header=FALSE, skip=1, nrows=1, sep="\t", fill=FALSE)
  # delete the NA entries for the tab-tab columns
  descriptions <- descriptions[!is.na(descriptions)]
  names(descriptions) <- headings[3:length(headings)]

  # handle optionally missing number of lines (not used, but need to decide whether to ignore before actual data)  
  numLines <- as.list(read.table(filename, header=FALSE, skip=2, nrows=1, sep="\t", fill=FALSE))
  numLines <- numLines[!is.na(numLines)] # remove NA entries
  skip <- (3 - ifelse(length(numLines) == 1, 0, 1)) # skip 3 lines if line number is present, 2 otherwise

  columns <- length(headings) - 2 # substract 2 for gene description and name 
  colClasses <- c(c("character", "character"), rep(c("double", "character"), columns))
  colNames <- headings[3:length(headings)]
  
  x <- .my.read.table(filename, header=FALSE, sep="\t", comment.char="", skip=skip, colClasses=colClasses, row.names=NULL, quote=NULL, fill=FALSE)
  
  data <-x[c(seq(from=3,length=(dim(x)[2]-3)/2, by=2))]
  calls <-x[c(seq(from=4,length=(dim(x)[2]-3)/2, by=2))]
  
  row.names <- x[,2]
  row.names(data) <- row.names
  row.names(calls) <- row.names
  gene.descriptions <- as.character(x[, 1])
  names(data) <- colNames
  names(calls) <- colNames
  r <- new("res", gene.descriptions=gene.descriptions, sample.descriptions=descriptions, data=data, calls=calls)
  r
}

# like read.table, but doesn't check to make sure all rows have same number of columns
.my.read.table <- function (file, header = FALSE, sep = "", quote = "\"'", dec = ".", row.names, col.names, as.is = FALSE, na.strings = "NA", colClasses, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = "") 
{
	if (is.character(file)) {
		file <- file(file, "r")
		on.exit(close(file))
	}
	if (!inherits(file, "connection")) 
		stop("argument `file' must be a character string or connection")
	if (!isOpen(file)) {
		open(file, "r")
		on.exit(close(file))
	}
	if (skip > 0) 
		readLines(file, skip)
		
	first <- readLines(file, n=1) 
	pushBack(first, file)
	temp <- strsplit(first, "\t") 
	cols <- as.integer(length(temp[[1]])) # number of columns
	 
	if (missing(col.names)) 
        col.names <- paste("V", 1:cols, sep = "")
	
	what <- rep(list(""), cols)
	names(what) <- col.names
	colClasses[colClasses %in% c("real", "double")] <- "numeric"
	known <- colClasses %in% c("logical", "integer", "numeric", "complex", "character")
	what[known] <- sapply(colClasses[known], do.call, list(0))
    
	data <- scan(file = file, what = what, sep = sep, quote = quote, dec = dec, nmax = nrows, skip = 0, na.strings = na.strings, quiet = TRUE, fill = fill, strip.white = strip.white, blank.lines.skip = blank.lines.skip, multi.line = FALSE, comment.char = comment.char)
	nlines <- length(data[[1]])
	if (cols != length(data)) {
		warning(paste("cols =", cols, " != length(data) =", length(data)))
		cols <- length(data)
	}
	if (is.logical(as.is)) {
        as.is <- rep(as.is, length = cols)
	}
	else if (is.numeric(as.is)) {
	  if (any(as.is < 1 | as.is > cols)) 
			stop("invalid numeric as.is expression")
	  i <- rep(FALSE, cols)
	  i[as.is] <- TRUE
	  as.is <- i
	}
	else if (is.character(as.is)) {
	  i <- match(as.is, col.names, 0)
	  if (any(i <= 0)) 
			warning("not all columns named in as.is exist")
	  i <- i[i > 0]
	  as.is <- rep(FALSE, cols)
	  as.is[i] <- TRUE
	}
	else if (length(as.is) != cols) 
		stop(paste("as.is has the wrong length", length(as.is), 
			"!= cols =", cols))
	if (missing(row.names)) {
		if (rlabp) {
			row.names <- data[[1]]
			data <- data[-1]
	  }
	  else row.names <- as.character(seq(len = nlines))
	}
	else if (is.null(row.names)) {
		row.names <- as.character(seq(len = nlines))
	}
	else if (is.character(row.names)) {
		if (length(row.names) == 1) {
			rowvar <- (1:cols)[match(col.names, row.names, 0) == 
				 1]
			row.names <- data[[rowvar]]
			data <- data[-rowvar]
	  }
	}
	else if (is.numeric(row.names) && length(row.names) == 1) {
	  rlabp <- row.names
	  row.names <- data[[rlabp]]
	  data <- data[-rlabp]
	}
	else stop("invalid row.names specification")
	class(data) <- "data.frame"
	row.names(data) <- row.names
	data
}

write.res <-
#
# write a res structure as a file
#
function(res, filename)
{
	if(!inherits(res,"res")) {
		stop("argument `res' must be a res structure.")
	}
	f <- file(filename, "w")
	
	# write the labels
	cat("Description\tAccession\t", file=f, append=TRUE)
	cat(names(res@data), sep="\t\t", file=f, append=TRUE)
	cat("\n", file=f, append=TRUE)
	
	# write the descriptions
	cat("\t", file=f, append=TRUE)
	cat(res@sample.descriptions, sep="\t\t", file=f, append=TRUE)
	cat("\n", file=f, append=TRUE)
	
	# write the size
	cat(NROW(res@data), "\n", sep="", file=f, append=TRUE)
	
	# write the data
	# 1st combine matrices
	dim <- dim(res@data)
	dim[2] <- dim[2]*2
	
	m <- matrix(nrow=dim[1], ncol=dim[2]+1)
	row.names(m) <- res@gene.descriptions
	m[,1] <- row.names(res@data)
	
	index <- 2
	for(i in 1:dim(res@data)[2]) {
		m[,index] <- res@data[,i]
		index <- index + 2
	}
	index <- 3
	for(i in 1:dim(res@calls)[2]) {
		m[,index] <- res@calls[,i]
		index <- index + 2
	
	}
	write.table(m, file=f, col.names=FALSE, row.names=TRUE, append=TRUE, quote=FALSE, sep="\t", eol="\n")
	close(f)
	return(filename)
}

read.cls <- function(file) {
	# returns a list with class "cls" containing the following components: 
	# labels the factor of class labels
	# names the names of the class labels if present
	if (is.character(file)) 
        if (file == "") 
            file <- stdin()
        else {
            file <- file(file, "r")
            on.exit(close(file))
        }
    if (!inherits(file, "connection")) 
        stop("argument `file' must be a character string or connection")
        
	line1 <- scan(file, nlines=1, what="character", quiet=TRUE)
	numberOfDataPoints <- as.integer(line1[1])
	numberOfClasses <- as.integer(line1[2])
	
	line2 <- scan(file, nlines=1, what="character", quiet=TRUE)
	classNames <- NULL
	if(line2[1] =='#') { # class names are given
		classNames <- as.vector(line2[2:length(line2)])
		line3 <- scan(file, nlines=1, quiet=TRUE)
	} else {
		line3 <- line2
	}
	labels <- as.factor(line3)
	if(numberOfDataPoints!=length(labels)) {
		stop("Incorrect number of data points") 	
	}
	r <- list(labels=labels,names=classNames)
	class(r) <- "cls"
	r
}


write.cls <-
#
# write a CLS result to a file.
function(cls, file)
{
	if (is.character(file)) 
        if (file == "") 
            file <- stdin()
        else {
            file <- file(file, "w")
            on.exit(close(file))
        }
    	if (!inherits(file, "connection")) 
        	stop("argument `file' must be a character string or connection")
	
	if(class(cls) != "cls") {
		stop("argument `cls' must be of class cls")
	}	
	cat(file=file, length(cls$labels), length(levels(cls$labels)), "1\n")

	if(length(cls$names) > 0) {
		cat(file=file, "# ")
		for(i in 1:(length(cls$names) - 1)) {
			cat(file=file, cls$names[i])
			cat(file=file, " ")
		}
		cat(file=file, cls$names[length(cls$names)])
		cat(file=file, "\n")
	}
	for(i in 1:(length(cls$labels)-1)) {
		cat(file=file, cls$labels[[i]]-1)
		cat(file=file, " ")
	}
	cat(file=file, cls$labels[[length(cls$labels)]]-1)
}

# deprecated: use gpReadFile
readFile <- function(...) { gpReadFile(...) }

gpReadFile <-
#
# read a file into a string
# input parameter is either a filename, a list of filenames, or a result object (containing a list of filenames)
#
function(filename, timeout=60)
{
	if (is.null(filename)) return (NULL)
	if (is.null(class(filename))) class(filename) <- "character"
	if (class(filename) == "status") {
		return(filename@error)
	}
	if (class(filename) == "result") {
		return(lapply(filename@filenames, gpReadFile))
	}
	if (class(filename) == "list") {
		return(lapply(filename, gpReadFile))
	}
	if (class(filename) != "character") {
		return (paste("Error: unexpected input type: ", class(filename), sep="", collapse="")) # filename@message
	}
	if (length(grep("^http", filename)) == 0) {
		if (!file.exists(filename)) {
			stop(paste("gpReadFile:", filename, "doesn't exist"))
		}
	}
	oldTimeout <- options("timeout"=timeout)
#	options("internet.info"=1)
	oldWarn <- options("warn"=-1)[[1]] # avoid the readLines warning about an incomplete final line
	err <- try (data <- paste(readLines(filename), sep="", collapse="\r\n"))
	options("warn"=oldWarn)
	options("timeout"=oldTimeout)
	if (class(err) == "try-error") {
		warning(err[[1]], " reading from ", filename)
		data <- NULL
	}
	return(data)
}

gpResultAsGCT <-
#
#
#
function(txt)
{
	con2 <- textConnection(txt, open="r")
	oldWarn <- options(warn=-1)
	return(read.gct(con2))
}


gpSaveAs <-
#
# rename a file to a GCT file
#
function(oldName, newName)
{
	if (missing(oldName) || missing(newName) || is.null(oldName) || is.null(newName) || newName == "") {
		return (oldName);
	}
	if (length(grep("[/\\]", newName)) == 0) {
		newName <- file.path(getwd(), newName)
	}
	# need to replace forward slashes with filesystem-appropriate ones.  file.path is broken!
	if (.Platform$file.sep == "\\") newName <- gsub("/", "\\\\", newName, FALSE)
	if (oldName == newName) return(newName)
	if (file.exists(newName)) file.remove(newName);
	if (!file.exists(dirname(newName))) dir.create(dirname(newName))
	if (!file.rename(oldName, newName)) {
		file.copy(oldName, newName, TRUE)
		file.remove(oldName)
	}
	return(newName)
}

write.gct <-
#
# save a GCT result to a file.
#
function(gct, filename)
{
	if (!inherits(gct, "gct")) {
		stop("argument `gct' must be a gct structure.")
	}
	result <- regexpr(paste(".gct","$",sep=""), tolower(filename))
	if(result[[1]] == -1) {
		filename <- paste(filename, ".gct", sep="") # ensure correct file extension
	}
	f <- file(filename, "w")
	cat("#1.2", "\n", file=f, append=TRUE, sep="")
	cat(dim(gct@data)[1], "\t", dim(gct@data)[2], "\n", file=f, append=TRUE, sep="")
	cat("Name", "\t", file=f, append=TRUE, sep="")
	cat("Description", file=f, append=TRUE, sep="")
	names <- names(gct@data)
	cat("\t", names[1], file=f, append=TRUE, sep="")
	for(j in 2:length(names)) {
		cat("\t", names[j], file=f, append=TRUE, sep="")
	}
	cat("\n", file=f, append=TRUE, sep="")
	oldWarn <- options(warn=-1)
	
	m <- matrix(nrow = dim(gct@data)[1], ncol = dim(gct@data)[2] + 2)
	m[, 1] <- row.names(gct@data)
	m[, 2] <- gct@row.descriptions
	index <- 3
	for (i in 1:dim(gct@data)[2]) {
		m[, index] <- gct@data[, i]
		index <- index + 1
	}
	write.table(m, file=f, append=TRUE, quote=FALSE, sep="\t", eol="\n", col.names=FALSE, row.names=FALSE)
	close(f)
	options(warn=0)
	return(gct)
}

gpHelp <-
#
# display online help for a task
#
function(taskName, file="", userID=get("userID", envir=globalenv()), server=defaultServer)
{
	# if no filename was specified
	server <- gpNormalizeServer(server)
	url <- paste("http://", server@host, ":", server@port, "/gp/getTaskDoc.jsp?name=", taskName, "&userid=", userID, "&file=", file, sep="", collapse="")
	browseURL(url)
}

gpTasksAsFunctions <-
#
# create functions for each accessible GenePattern task
# implementation: JSP page returns R code that recapitulates task as function, calling runAnalysis
#
function(server=defaultServer, userID=get("userID", envir=globalenv())) {
	server <- gpNormalizeServer(server)
	source(paste("http://", server@host, ":", server@port, "/gp/getAllTaskWrappers.jsp?language=R&userid=", userID, sep="", collapse=""))
}

gpRunByLSID <-
#
# Run a module given an LSID.  Find the right one to get all of the proper parameters and default values.
# Return list of results filenames or status if error occurred
#
function(LSID, ...)  {
	# lookup function by name or LSID
	f <- gpGetParameters[[LSID]]
	if (is.null(f)) {
		stop("No such module: ", LSID);
	} else {
		args <- list(...);

		# find all formals with no matching actual parameters
		for (arg in 1:length(formals(f))) {
			if (!is.null(args[[names(formals(f)[arg])]])) next;
			args <- c(args, formals(f)[arg]);
			#cat("adding unspecified parameter", names(formals(f))[arg], "=", formals(f)[[arg]], "\n");
		}

		# find all input arguments that aren't named and add them (???)
		for(arg in 1:length(args)) {
		    if (nchar(names(args)[arg]) == 0) {
			#cat("setting nameless arg", arg, "to", names(formals(f)[arg]), "\n");
			names(args)[arg] <- names(formals(f)[arg])
		    }
		    #cat(names(args)[arg], "=", args[[arg]], "\n", sep="")
		}

		#cat("gpRunByLSID: calling f(...) with", length(args), "args: ");
		# now invoke the module with all arguments named and set
		return (do.call("f", args));
	}
}

gpLogin <-
#
# create functions for each accessible GenePattern task
# implementation: JSP page returns R code that recapitulates task as function, calling runAnalysis
#
function(userid=get("userID", envir=globalenv()), server=defaultServer) {
	if (!is.null(userid) && userid == "") userid <- gpAskUser("username", "", F)
	userID <<- userid
	server <- gpNormalizeServer(server)
	if (!is.null(userID) && userID != "") {
		gpEncodedUserName <<- readFile(paste("http://", server@host, ":", server@port, "/gp/login.jsp?userid=", userid, "&getBasicAuthentication=1", sep="", collapse=""))
	} else {
		gpEncodedUserName <<- ""
	}
}

gpBeginPipeline <-
#
# verify that each task defined in the pipeline actually exists on this server
#
function(name, ..., server=defaultServer)
{
 server <- gpNormalizeServer(server)
 if (!exists("runningOnServer", envir=globalenv())) assign("runningOnServer", FALSE, env=globalenv())
 gpTasksAsFunctions(server)
 missingTasks <- ""
 tasks <- list(...)
 assign("numTasksInPipeline", length(tasks), env=parent.env(environment()))
 assign("taskNum", 1, env=parent.env(environment()))

 # get jobID as set by caller prior to invocation
 if (runningOnServer) assign("pipelineJobID", jobID, env=parent.env(environment()))

 t <- 1
 for(lsid in tasks) {
	err <- ""
	taskName <- names(unlist(list(...))[t]);
	if (is.null(taskName)) {
		# old pipeline with no LSIDs on RHS
		taskName <- lsid
		err <- try(lsid <- formals(taskName)[["LSID"]])
	}
	if (class(err) == "try-error" || length(gpGetParameters[[lsid]]) == 0) {
		missingTasks <- paste(missingTasks, ifelse(nchar(missingTasks) > 0, ", ", ""), taskName, "(", lsid, ")", sep="", collapse="")
	}
	t <- (t+1);
 }
 if (nchar(missingTasks) > 0) {
	stop("No such task(s): ", missingTasks)
 }

 if (runningOnServer) {
	cat("Pipeline summary: ")

	 t <- 1
	 for(lsid in tasks) {
		taskName <- names(unlist(list(...))[t]);
		if (is.null(taskName)) {
			# old pipeline with no LSIDs on RHS
			taskName <- lsid
			lsid <- formals(taskName)[["LSID"]]
		}
		cat("<a href=\"http://", server@host, ":", server@port, "/gp/addTask.jsp?name=", lsid, "\">", taskName, "</a>", sep="")
		if (t < length(tasks)) cat(", ");
		t <- (t+1);
	 }
	cat("<br><br>\n")

 }

 if (runningOnServer) {
		cat("<form name=\"results\" action=\"http://", server@host, ":", server@port, "/gp/zipJobResults.jsp\">\n", sep="")
		cat("<input type=\"hidden\" name=\"name\" value=\"", name, "\">\n")
		cat("<input type=\"hidden\" name=\"jobID\" value=\"", pipelineJobID, "\">\n", sep="")
		cat("<table cols=\"2\">\n")
		cat("<tr><td valign=\"top\" width=\"20\"><u>step</u></td><td valign=\"top\"><u>name and parameters</u></tr>\n");
		close(url(paste("http://", server@host, ":", server@port, "/gp/updatePipelineStatus.jsp?jobID=", pipelineJobID, "&jobStatus=2", sep="", collapse=""), open="r"))
 }
}

gpRunVisualizer <-
#
# run a visualizer locally
#
# 	args[0] = visualizer task name
#	args[1] = command line
#	args[2] = debug flag
#  	args[3] = OS required for running
#	args[4] = CPU type required for running
#  	args[5] = libdir on server for this task
# 	args[6] = CSV list of downloadable files for inputs
#	args[7] = CSV list of input parameter names
#	args[8] = CSV list of support file names
#	args[9] = CSV list of support file modification dates
#	args[10] = visualizer LSID
#	args[11] = server URL
#	args[12...n] = optional input parameter arguments
#
function(taskName, .commandLine, .libDir=null, .os="any", .cpuType="any", .downloadableFiles="", .parameterNames="", .supportFilenames="", .supportFileDates="", .lsid="", ..., server=defaultServer, showOutput=FALSE)
{
	server <- gpNormalizeServer(server)

	GPHome <- file.path(.find.package("GenePattern"))
	if (!file.exists(GPHome)) {
		GPHome <- "C:/Program Files/GenePattern/Tomcat/webapps/gp";
	}
	if (!file.exists(GPHome)) {
		GPHome <- "";
		cat("Don't know how to find runVisualizer.jar", file=stderr())
		return
	}

	java <- gpFindJava()
	commandLine <- paste(java, "-jar", 
			     gpQuote(file.path(GPHome, "runVisualizer.jar")),
			     taskName,
			     gpQuote(.commandLine), 
			     ifelse(showOutput, "true", "\"\""), 
			     gpQuote(.os),
			     gpQuote(.cpuType),
			     gpQuote(.libDir),
			     gpQuote(.downloadableFiles),
			     gpQuote(.parameterNames), 
			     gpQuote(.supportFilenames), 
			     gpQuote(.supportFileDates), 
			     paste("http://", server@host, ":", server@port, sep="", collapse=""),
			     gpQuote(.lsid), 
			     paste(sapply(list(...), 
				   function (param) { 
					if (class(param) == "resultFilename") param<-param@value; 
					return (paste(gpQuote(param), " ", sep="", collapse="")) 
				   }), sep="", collapse=""),
			     sep=" ", collapse="")

	# cat("running", commandLine, "\n")
	if (Sys.info()[["sysname"]]=="Windows") {
		err <- try(system(commandLine, show.output.on.console=showOutput, invisible=FALSE), silent=FALSE)
	} else {
		err <- try(system(commandLine, intern=TRUE), silent=TRUE)
	}
	if (class(err) == "try-error") {
		cat(err, "\n", file=stderr())
	} else if (showOutput) {
		cat(err, "\n")
	}
}

gpQuote <- function(...) {
	return (paste("\"", ..., "\"", sep="", collapse=""))
}

.First.lib <- function(libname = null, pkgname = "GenePattern") {
	isWindows <<- Sys.info()[["sysname"]]=="Windows"
	slash <<- .Platform$file.sep
#	cat("Loading GenePattern library...")
	if (isWindows) flush.console()

	# Default settings are customized based on install-time settings
	p <- gpReadFile(file.path(.find.package(pkgname), "R", "genepattern.properties"))
	eval(parse(text=gsub("\\\\", "/", gsub("\r\n", "\n", p))))
	props[["startServerCmd"]] <<- paste("'\"", props[["startServerCmd"]], "'\"", sep="", collapse="")
	GenePatternVersion <<- props[["genePatternVersion"]]



	options(echo = TRUE)
	if (!require("methods", quietly=TRUE)) {
		install.packages("methods")
		stopifnot(require("methods"))
	}
	if (!require("XML", quietly=TRUE)) {
		install.packages("XML")
		stopifnot(require("XML"))
	}

	setClass("SOAPEnvelope", representation())
	setClass("SOAPActor", representation())
	setClass("SOAPFault", representation(message="character", actor="SOAPActor", detail="ANY"))
	setClass("SOAPVersionMismatchFault", representation("SOAPFault"))
	setClass("SOAPMustUnderstandFault", representation("SOAPFault"))
	setClass("SOAPClientFault", representation("SOAPFault"))
	setClass("SOAPServerFault", representation("SOAPFault"))
	setClass("SOAPGeneralFault", representation("SOAPFault", code="character"))
	setClass("SOAPServer", representation(host = "character", port = "integer", url = "character"), prototype = list(host = "", port = as.integer(props[["serverPort"]]), url="" ))
	setClass("HTTPSOAPServer", representation("SOAPServer"))
	setClass("FTPSOAPServer", representation("SOAPServer"), prototype = list(host = "", port = as.integer(21), url="" ))

	setClass("gct", representation(row.descriptions="character", data="data.frame"))
	setClass("res", representation(gene.descriptions="character", sample.descriptions="character", data="data.frame", calls="data.frame"))

	setClass("result", representation(success="logical", error="SOAPFault", filenames="list", jobID="integer", server="SOAPServer"))
	setClass("status", representation(busy="logical", success="logical", error="character", hasOutput="logical", filenames="list", serverFilenames="list", jobID="integer", server="SOAPServer"))
	setClass("resultFilename", representation(name="character", value="character"))

	if (!exists("defaultServer", envir=globalenv())) {
		defaultServer <<- paste(props[["serverName"]], ":", props[["serverPort"]], sep="", collapse="")
		startServer <<- props[["startServerCmd"]]
	}
	handlers <<- SOAPHandlers()

	# fake socket open so that the first real one doesn't fail
	oldWarn <- options("warn" = -1)[[1]]
	oldError <- options("show.error.messages"=FALSE)[[1]]
	tcon <- NULL
	try (tcon <- socketConnection(defaultServer@host, port = defaultServer@port, open = "w+", blocking = TRUE))
	if (!is.null(tcon) && isOpen(tcon)) close(tcon)
	rm(tcon)
	options("show.error.messages"=oldError)
	options("warn"=0)

	# seconds to wait when checking for job completion status
	if (!exists("POLLING.INTERVAL", envir=globalenv())) {
		POLLING.INTERVAL <<- 3
	}

	# buffer size for block reads/writes.
	# BUG: Too large a BUFSIZE value will cause R to drop parts of the buffer when writing to the Axis socket!
	BUFSIZE <<- 8192

#	cat(" loaded\n")
	if (isWindows) flush.console()
	if (!exists("userID", envir=globalenv())) {
		userID <<- ""
	} else {
		gpEncodedUserName <<- gpLogin(userID, defaultServer)
	}
	if (!exists("gpEncodedUserName", envir=globalenv())) gpEncodedUserName <<- ""
}

gpUseResult <- function(filename)
{
	if (is.null(filename) || is.null(unlist(filename))) return("")
	r <- new("resultFilename", name=deparse(substitute(filename)), value=unlist(filename))
	name <- names(unlist(filename))
	names(r@value) <- name
	return (r)
}

gpFindJava <- function()
{
	isWindows <- Sys.info()[["sysname"]]=="Windows"
	java <- file.path(Sys.getenv("JAVA_HOME"), "bin", "java")
	if (isWindows) java <- paste(java, ".exe", sep="")
	if (!file.exists(java)) {
		if (isWindows) {
			java <- paste(Sys.getenv("COMSPEC"), "/c", "java", sep=" ")
			err <- try(system(paste(java, "-version", sep=" "), intern=TRUE), silent=TRUE)
			if (class(err) == "try-error") {
				cat("Unable to find java\n", file=stderr())
				return
			}
		} else {
			java <- system("which java", intern=TRUE)[[1]]
			if (length(grep("^/", java)) == 0) {
				cat("Unable to find java\n", file=stderr())
				return
			}
		}
	}
	return (java)
}

gpGetLatestVersionLSID <- function(taskName) 
{
	err <- try(return (formals(taskName)[["LSID"]]), silent=TRUE);
	return (paste("No such task", taskName));
		
}

#do.call(".First.lib", list(libname="GenePattern", pkgname="GenePattern"))
