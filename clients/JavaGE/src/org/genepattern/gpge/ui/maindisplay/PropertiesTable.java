/*
 * PropertiesTable.java
 *
 * Created on March 3, 2003, 4:32 PM
 */

package org.genepattern.gpge.ui.maindisplay;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.swing.JList;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;

import org.genepattern.data.DataModel;
import org.genepattern.gpge.io.DataObjectProxy;
import org.genepattern.gpge.io.GroupDataSource;
import org.genepattern.io.SummaryError;
import org.genepattern.io.SummaryInfo;



/**
 *
 * @author  kohm
 */
public class PropertiesTable extends org.genepattern.modules.ui.graphics.BaseTable/*javax.swing.JTable*/ implements DataSelectListener {
    
    /** Creates new form PropertiesTable */
    public PropertiesTable() {
        super(false);
        initComponents();
        tmp_map = new TreeMap();
        tmp_array = new Object[2];
        //setDefaultRenderer(String[].class, new ArrayRenderer());
        setDefaultRenderer(Object.class, new ArrayRenderer());
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents

        setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Name", "Value(s)"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Object.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
    }//GEN-END:initComponents
    /** helper gets the DefaultTableModel */
    private final DefaultTableModel getDefaultModel() {
        return (DefaultTableModel)this.getModel();
    }
    /** sets the props */
    protected void setAttributes(final Map attrs) {
        final Object[] rowData = this.tmp_array; // make local
        final DefaultTableModel model = getDefaultModel();
        final Set keyset = attrs.keySet();
        for(final Iterator iter = keyset.iterator(); iter.hasNext(); ) {
            final Object key = iter.next();
            final Object value = attrs.get(key);
            
            String name = key.toString();
            // remove the delimiter if present
            final int last = name.length() - 1;
            final char del = name.charAt(last);
            if( del == ':' || del == '=' )
                name = name.substring(0, last);
            
            rowData[0] = name;
            rowData[1] = value;
            //rowData[1] = (value instanceof Object[]) ? ((Object)new JList((Object[])value)) : value;
            model.addRow(rowData);
        }
//        model.fireTableDataChanged();
    }
    /** removes all data from the table */
    protected void clearTable() {
        final DefaultTableModel model = getDefaultModel();
        for(int i = model.getRowCount() - 1; i >= 0; i--) { // rev loop 
            model.removeRow(i);
        }
//        model.fireTableDataChanged();
    }
    
    // DataSelectListener interface methods
    
    /** notifies the listener that a DataModel Node has been selected   */
    public void dataModelSelected(final DataModel model, final Object node) {
        System.out.println("PropertiesTable: dataModelSelected "+model);
        tmp_map.clear();
        
        tmp_map.put("Data model=", model.toString());
        final DefaultMutableTreeNode nd = (DefaultMutableTreeNode)node;
        tmp_map.put("Count=",    String.valueOf(nd.getChildCount()));
        clearTable();
        setAttributes(tmp_map);
        
        getDefaultModel().fireTableDataChanged();
    }    
    
    /** notifies the listener that a DataObjectProxy Node has been selected   */
    public void dataProxySelected(final DataObjectProxy proxy, final Object node) {
        System.out.println("PropertiesTable: dataProxySelected "+proxy);
        //"Data object "+ proxy.getName())); 
        tmp_map.clear();
        
        tmp_map.put("Name=", proxy.getName());
        tmp_map.put("Data Model=", proxy.getDataModel());
        tmp_map.put("Source=", proxy.getDataSourceDescription());
        clearTable();
        
        final SummaryInfo info = proxy.getSummaryInfo();
        final Map primary = info.getPrimaryinfo();
        if( info instanceof SummaryError ) {
            tmp_map.putAll(primary);
            setAttributes(tmp_map);
        } else {
            setAttributes(tmp_map);
            setAttributes(primary);
        }
        
        setAttributes(info.getSecondaryInfo());
        
        getDefaultModel().fireTableDataChanged();
    }    
    
    /** the listener is notified that a DirDataSource has been selected  */
    public void dataSourceSelected(final GroupDataSource source, final Object node) {
		 
        System.out.println("PropertiesTable: dataSourceSelected "+source);
        tmp_map.clear();
        clearTable();
		  if(source instanceof org.genepattern.gpge.io.ServerSiteDataSource) {
			  tmp_map.put("Location", source.toString());
		  } else if(source instanceof org.genepattern.gpge.io.ServerTaskDataSource) {
			  tmp_map.put("Task", source.toString());
			  javax.swing.tree.TreeNode tn = (javax.swing.tree.TreeNode) node;
			  tmp_map.put("Number of jobs", String.valueOf(tn.getChildCount()));
		  } else if(source instanceof org.genepattern.gpge.io.DirDataSource) { //project dir
			  tmp_map.put("Location=", source.getLocation());
			  tmp_map.put("Count=", String.valueOf(source.getCount()));
		  } else if(source instanceof org.genepattern.gpge.io.ServerJobDataSource) { 
			  tmp_map.put("Output files=", String.valueOf(source.getCount()));
		  } else {
			   tmp_map.put("Count=", String.valueOf(source.getCount()));
		  }
        setAttributes(tmp_map);

        getDefaultModel().fireTableDataChanged();

    }
    
    /** indicates that some unknown node was selected  */
    public void unknownSelected(final Object source) {
        System.out.println("PropertiesTable: unknownSelected "+source);
        tmp_map.clear();
        clearTable();
        tmp_map.put("Node=", source);
        setAttributes(tmp_map);
        
        //final Map empty = java.util.Collections.EMPTY_MAP;
        //primary_viewer.setAttributes(empty);
        //setAttributes(empty);
        //secondary_viewer.setAttributes(empty);
        //setAttributes(empty);
        
        getDefaultModel().fireTableDataChanged();
    }
    
    // end interface methods
    
    /** the scratch atrributes Map */
    private final Map tmp_map;
    /** scratch array */
    private final Object[] tmp_array;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /** renderer for String arrays */
    static class ArrayRenderer extends javax.swing.table.DefaultTableCellRenderer {
        /** defines the empty string */
        private static final String EMPTY_STRING = "";
        /** constructor */
        public ArrayRenderer() {
            super();
        }
        /** sets the value if it is an array */
        public final void setValue(final Object value) {
            String text = EMPTY_STRING;
            if( value instanceof String[] ) {
                text = org.genepattern.util.ArrayUtils.toString((String[])value);
            } else if( value != null) {
                text = value.toString();
            } 
            setText(text);
            setToolTipText(text);
        }
        
    }
}
